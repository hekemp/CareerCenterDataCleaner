<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Data Cleaner</title>
  <meta name="description" content="Pomerantz Career Center Data Cleaner">
  <meta name="author" content="Pomerantz Career Center">

  <link rel="stylesheet" href="css/styles.css">



</head>


<body>

<script>
  // Check for the various File API support.
  if (window.File && window.FileReader && window.FileList && window.Blob) {
    // Great success! All the File APIs are supported.
  } else {
    alert('The File APIs are not fully supported in this browser.');
  }
</script>

<style>
  #progress_bar {
    margin: 10px 0;
    padding: 3px;
    border: 1px solid #000;
    font-size: 14px;
    clear: both;
    opacity: 0;
    -moz-transition: opacity 1s linear;
    -o-transition: opacity 1s linear;
    -webkit-transition: opacity 1s linear;
  }
  #progress_bar.loading {
    opacity: 1.0;
  }
  #progress_bar .percent {
    background-color: #99ccff;
    height: auto;
    width: 0;
  }
</style>

File To Change: <input type="file" id="files" name="file" />
CSV: <input type="file" id="keys" name="key" />
<div id="progress_bar"><div class="percent">0%</div></div>

Row: <input type="text" name="RowToChange" id="RowToChange" value=""><br>

<button onclick="startCleaning();">Start Cleaning</button><br>

New name of file: <input type="text" name="FileName" id="FileName" value="">.csv<br>
<button onclick="downloadFile();">Download File</button><br>
Note: This file is downloaded to your Downloads folder.

<script>
  var reader;
  var progress = document.querySelector('.percent');

  var readText;
  var keyText;
  var rowChanging;

  var readInList = [];
  var keyInList = [];

  var foundKeyValues = {};
  var toAssign = {};

  function abortRead() {
    reader.abort();
  }

  function errorHandler(evt) {
    switch(evt.target.error.code) {
      case evt.target.error.NOT_FOUND_ERR:
        alert('File Not Found!');
        break;
      case evt.target.error.NOT_READABLE_ERR:
        alert('File is not readable');
        break;
      case evt.target.error.ABORT_ERR:
        break; // noop
      default:
        alert('An error occurred reading this file.');
    };
  }

  function updateProgress(evt) {
    // evt is an ProgressEvent.
    if (evt.lengthComputable) {
      var percentLoaded = Math.round((evt.loaded / evt.total) * 100);
      // Increase the progress bar length.
      if (percentLoaded < 100) {
        progress.style.width = percentLoaded + '%';
        progress.textContent = percentLoaded + '%';
      }
    }
  }

  function handleKeysSelect(evt) {
    // Reset progress indicator on new file selection.
    progress.style.width = '0%';
    progress.textContent = '0%';

    reader = new FileReader();
    reader.onerror = errorHandler;
    reader.onprogress = updateProgress;
    reader.onabort = function(e) {
      alert('File read cancelled');
    };
    reader.onloadstart = function(e) {
      document.getElementById('progress_bar').className = 'loading';
    };
    reader.onload = function(e) {
      // Ensure that the progress bar displays 100% at the end.
      progress.style.width = '100%';
      progress.textContent = '100%';
      setTimeout("document.getElementById('progress_bar').className='';", 2000);


      keyText = reader.result;

    }



    // Read in the image file as a binary string.
    reader.readAsText(evt.target.files[0]);


  }

  function handleFileSelect(evt) {
    // Reset progress indicator on new file selection.
    progress.style.width = '0%';
    progress.textContent = '0%';

    reader = new FileReader();
    reader.onerror = errorHandler;
    reader.onprogress = updateProgress;
    reader.onabort = function(e) {
      alert('File read cancelled');
    };
    reader.onloadstart = function(e) {
      document.getElementById('progress_bar').className = 'loading';
    };
    reader.onload = function(e) {
      // Ensure that the progress bar displays 100% at the end.
      progress.style.width = '100%';
      progress.textContent = '100%';
      setTimeout("document.getElementById('progress_bar').className='';", 2000);


      readText = reader.result;

    }



    // Read in the image file as a binary string.
    reader.readAsText(evt.target.files[0]);


  }

  document.getElementById('files').addEventListener('change', handleFileSelect, false);
  document.getElementById('keys').addEventListener('change', handleKeysSelect, false);



  //download(reader.result, "test", "text/csv");

  function download(data, filename, type) {
    var file = new Blob([data], {type: type});
    if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
        var a = document.createElement("a"),
                url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
      }
    }

    var mapLetterValue = function(val) {
      var base = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', i, j, result = 0;

      for (i = 0, j = val.length - 1; i < val.length; i += 1, j -= 1) {
        result += Math.pow(base.length, j) * (base.indexOf(val[i]) + 1);
      }

      return result;
    };

    function startCleaning(){

      // If a value is out of range, then it's undefinded, if I val is undefined, ignore it
      // [var].map(mapLetterValue);

      var rowToChange = document.getElementById("RowToChange").value;
      rowToChange = rowToChange.toUpperCase();

      rowChanging = [ rowToChange ].map(mapLetterValue)[0] - 1;

      if(readText != null && keyText != null && rowChanging != null ){

        breakReadText();
        breakKeyText();

        var currentValue;
        for(var i = 1; i < readInList.length; i++) {
          currentValue = readInList[i][rowChanging];

          if (currentValue == ""); // empty row
          else if ((foundKeyValues[currentValue] != "" && foundKeyValues[currentValue] != null )) { // we already know the value
            readInList[i][rowChanging] = foundKeyValues[currentValue];
          } else {
              var locatedValue = findValue(currentValue);
              if (locatedValue != ""){ // Item was assigned a value
                foundKeyValues[currentValue] = locatedValue;
                readInList[i][rowChanging] = locatedValue;
              }
              else { // Item hasn't been assigned yet
                if(toAssign[currentValue] != "" && toAssign[currentValue] != null) { // Item has been found elsewhere
                  toAssign[currentValue][toAssign[currentValue].length] = i;
                }
                else { // This is the first time we've found this item
                  toAssign[currentValue] = [ i ];
                }
              }
          }
        }
      }

    }

    /* To get keys:
    for(item in toAssign){
      console.log(item);
    }
      To Get Items:
      for(item in toAssign){
        console.log(toAssign[item]);
      }
    */

    function findValue(itemToLocate){

      for(var i = 0; i < keyInList.length; i++) {
        for(var j = 0; j < keyInList[i].length; j++){
          if (keyInList[i][j] == itemToLocate){
            return keyInList[i][0];
          }
        }
      }
      return "";
    }

    function breakReadText(){

      var splitByLine = readText.split(/\r?\n/g);
      var splitByComma = [];
      for(var i = 0; i < splitByLine.length; i++){
        splitByComma[i] = splitByLine[i].split(',');

      }
      readInList = splitByComma;

    }

    function breakKeyText(){
      var splitByLine = keyText.split(/\r?\n/g);
      var splitByComma = [];
      for(var i = 0; i < splitByLine.length; i++){
        splitByComma[i] = splitByLine[i].split(',');

      }
      keyInList = splitByComma;

    }

    function reassembleReadText(){
      var splitByLine = [];
      for(var i = 0; i < readInList.length; i++){
        splitByLine[i] = readInList[i].join(',');
      }
      return splitByLine.join('\n');
    }

    function reassembleKeyText(){
      var splitByLine = [];
      for(var i = 0; i < keyInList.length; i++){
        splitByLine[i] = keyInList[i].join(',');
      }
      return splitByLine.join('\n');

    }

    function downloadFile(){
      var fileName = document.getElementById("FileName").value;
      if(fileName != "" && ( readInList != [] && readInList != null ) ) {
        var newText = reassembleReadText();
        download(newText, fileName, "text/csv");
      }

    }

</script>



</body>
</html>
